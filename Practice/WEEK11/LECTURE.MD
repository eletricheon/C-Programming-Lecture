# 배열
## 1. 선언
- int 형의 배열을 선언한다고 하면, 배열 명에 요소 개수를 붙여서 선언한다.

    ```c
    int a[7];   // int형 값 7개를 가지는 배열
    char b[30]; // char형 값 30개를 가지는 배열
    float c[8]; // float형 값 8개를 가지는 배열
    ```
    
    - `[]`안에는 요소의 개수가 들어가므로 음수나 0, 실수, 변수가 들어갈 수 없고 상수만 들어갈 수 있다. 
    
        ```c
        int scores[];       // 배열의 크기를 지정해야 한다.
        int scores[size];   // 배열의 크기가 변수일 수 없다.
        int scores[-2];     // 배열의 크기가 음수일 수 없다.
        int scores[6.7];    // 배열의 크기가 실수일 수 없다.
        ```
    
    - 변수의 크기로 기호상수를 사용할 수는 있다.
        
        ```c
        #define SIZE 10

        int scores[SIZE];
        ```

- 배열은 메모리의 연속적인 공간에 적용된다. 예를 들어 `a[0]`과 `a[1]`은 메모리상에 붙어있어서 차례로 접근하여 처리하기 용이하다.

## 2. 초기화 및 접근
- 다음과 같이 값을 초기화하면서 선언할 수도 있다.

    ```c
    int a[7] = {1, 2, 3, 4, 5, 6, 7};
    ```

    |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|`a[6]`
    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
    |1|2|3|4|5|6|7

- 초기화할 때 일부 요소만 값을 지정하면 나머지는 0으로 초기화된다.
    
    ```c
    int a[7] = {1, 2};
    ```

    |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|`a[6]`
    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
    |1|2|0|0|0|0|0


- 배열의 인덱스는 `0`부터 시작하므로 7개의 요소로 선언했다면 `0`부터 `6`까지의 인덱스로 접근할 수 있다.

- 배열의 각 요소에 접근할 때는 `for`문을 사용한다.
    ```c
    // 두 배열의 원소가 모두 같은지 비교

    #include <stdio.h>
    #define SIZE 5

    int main(void){
        int a[SIZE] = {1, 2, 3, 4, 5};
        int b[SIZE] = {1, 2, 3, 4, 5};

        for(int i = 0; i < SIZE; i++){
            if(a[i] != b[i]){
                printf("배열 a와 배열 b는 같지 않습니다.");
                return 0;
            }
        }

        printf("배열 a와 배열 b는 같습니다");
        return 0;
    }
    ```

- 함수에서의 배열 접근: 함수에서 매개변수로 배열을 전달하면 주소, 즉 원본이 전달된다.
    ```c
    // 배열이 아닌 다른 변수가 인자로 전달되는 경우

    #include <stdio.h>

    void swap(int a, int b){
        int temp = a;

        a = b;
        b = temp;
    }

    int main(void){
        int x = 3, y = 4;

        printf("Before Swap:\n");
        printf("x = %d\ny = %d", x, y);     // x = 3, y = 4로 출력
        swap(x, y);

        printf("After Swap:\n");
        printf("x = %d\ny = %d", x, y);    // x = 3, y = 4로 출력: swap 함수에서 전달되는 int 인자는 주소(원본)가 아니라 사본으로 값만 전달된다.
    }
    ```

    ```c
    // 배열이 함수의 인자로 전달되는 경우

    #include <stdio.h>

    void modifyArray(int a[], int size){
        for(int i = 0; i < size; i++){
            ++a[i];
        }
    }

    void printArray(int a[], int size){
        for(int i = 0; i < size; i++){
            printf("a[%d] = %d", i, a[i]);
        }
    }

    int main(void){
        int arr[5] = {1, 2, 3, 4, 5};

        modifyArray(arr, 5);
        printArray(arr, 5);
    }

    // a[0] = 2, a[1] = 3, a[2] = 4, a[3] = 5, a[4] = 6 출력
    ```
    
    - 함수에서 인자로 전달되는 배열의 변경을 방지하기 위해서는 `const`키워드를 사용한다.

        ```c
        void printArray(const int a[], size){
            ...
            a[0] = 100;     // 컴파일 오류
        }
        ```

## 3. 배열의 활용
- 정렬
    - 선택 정렬: 정렬되지 않은 요소들에서의 최솟값을 찾아 첫번째 요소와 교환

        i.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |5|7|1|3|

        &rarr; 인덱스 `0`부터 `3`까지 요소 중 최솟값 1을 첫번째 요소인 `a[0]`과 교환

        ii.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |**1**|7|5|3|

        &rarr; 정렬되지 않는 인덱스 `1`부터 `3`까지 요소 중 최솟값 3을 첫번째 요소인 `a[1]`과 교환

        iii.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |**1**|**3**|5|7|
        
        &rarr; 정렬 완료

- 탐색
    - 순차 탐색: 탐색키를 배열의 각 원소와 순서대로 비교하며 원하는 값 탐색

        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|
        |:---:|:---:|:---:|:---:|:---:|:---:|
        |10|20|30|40|50|60|

        `key = 30`

        i. `a[0] != key`이므로 다음 인덱스 탐색  
        ii. `a[1] != key`이므로 다음 인덱스 탐색  
        iii. `a[2] == key`이므로 탐색 종료

    - 이진 탐색: 정렬된 배열의 중앙에 위치한 값과 탐색키를 비교하는 과정을 반복
    
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|
        |:---:|:---:|:---:|:---:|:---:|:---:|
        |10|20|30|40|50|60|

        `key = 50`

        i. 중앙의 `a[2]`와 `key`비교 &rarr; `a[2] < key` 이므로 뒤의 요소들과 비교  
        ii. 인덱스 `3`부터 `5`까지에서의 중앙인 `a[4]`와 `key` 비교 &rarr; `a[4] = key`이므로 탐색 종료

## 4. 2차원 배열
- 2차원 배열의 선언과 초기화:   
    기본:  `int arr[ROWS][COLUMNS]`

    i.
    ```c
    int arr[3][5] = {
        {0, 1, 2, 3, 4},
        {10, 11, 12, 13, 14},
        {20, 21, 22, 23, 24}
    };
    ```
    ii.
    ```c
    int arr[ ][5] = { 
        { 0, 1, 2, 3, 4 }, 
        { 10, 11, 12, 13, 14 }, 
        { 20, 21, 22, 23, 24 }, 
    };
    ```
    iii.
    ```c
    int arr[][5] = {1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 21, 22, 23, 24}
    ```
    &rarr; i, ii, iii 모두 아래와 같이 초기화 된다.

    | |`[0]`|`[1]`|`[2]`|`[3]`|`[4]`|
    |:---:|:---:|:---:|:---:|:---:|:---:|
    |**`[0]`**|0|1|2|3|4|
    |**`[1]`**|10|11|12|13|14|
    |**`[2]`**|20|21|22|23|24|    

- 2차원 뿐만 아니라 3차원, 4차원 등 제한 없이 n차원 배열을 선언할 수 있다. 그러나 메모리 효율을 위해 3차원 이상의 배열은 가급적 사용하지 않는 것이 좋다.
# C-Programming-Lecture
# 변수
## 1. Scope 
- 지역변수
Scope: 선언된 블록
Lifetime: 블록이 종료되면 소멸

    ```c
    int func(int param);    // param같은 매개변수도 지역변수의 일종

    int main(void){
        int temp;   // 초기화되지 않았으므로 쓰레기값을 가짐
    }
    ```

- 전역변수
    - Scope: 소스파일 전체(함수 밖에 선언)
    - Lifetime: 프로그램 전체 기간동안 존속

        ```c
        #include <stdio.h>

        int temp;   // 따로 초기화하지 않아도 초기값은 0

        int main(void){

        }
        ```

- 하나의 블록 내에 같은 이름의 지역변수와 전역변수가 있을 때: 블록 내의 지역변수를 우선으로 참조

    ```c
    #include <stdio.h>

    int num = 1;    // 전역변수

    int main(void){
        int num = 0;    // 지역변수

        printf("num = %d\n", num);  // "sum = 0" 출력
    }
    ```

## 2. Lifetime
- 정적할당: 프로그램 실행시간 동안 메모리 유지
- 동적할당: 블록에 들어갈 때 생성, 블록에서 나갈때 소멸
- Lifetime 결정 요인: 변수가 선언된 위치, 저장 유형 자정자

    저장 유형 지정자: 
    - auto: 선언한 위치에서 자동으로 선언, 블록을 벗어날 때 자동으로 소멸(지역변수에서는 auto를 생략해도 자동변수가 됨)
    - register: CPU의 레지스터에 변수를 저장함. 
    - static: 정적변수를 선언할 때 사용한다.
    - extern: 
        - Linkage를 위해 사용
        - 지역변수와 전역변수의 이름이 같을 때, 블록 내에서 전역변수에 접근하기 위해 사용
            ```c
            #include <stdio.h> 

            int x = 50;

            int main(void){
                int x = 100;

                {
                    extern int x;
                    printf("global x = %d", x);
                }

                printf("local x = %d", x);
            }
            ```

            Output:
            ```
            global x = 50
            local x = 100
            ```


    - volatile: 컴파일러가 최적화를 중지하게 된다. 
        ```c
        *(unsigned int*)0x8C0F = 0x8001
        *(unsigned int*)0x8C0F = 0x8002
        *(unsigned int*)0x8C0F = 0x8003
        *(unsigned int*)0x8C0F = 0x8004
        ```

        위 4줄의 코드는 모두 같은 주소에서 연산을 수행하므로 컴파일러는 최적화를 통해 마지막줄 연산만 수행한다.  
        하드웨어를 제어하는 코드라면 최적화로 인해 오작동할 수 있으므로 volatile을 사용한다.

## 3. Linkage
- 연결(Linkage): 다른 범위에 속하는 변수들을 연결(전역변수만 가능)
    - 외부 연결: 전역변수 extern을 이용하여 연결
        ```c
        // file1.c
        extern int global;  // file2.c에 선언된 global과 연결

        // file2.c
        int global = 1;

        // file3.c
        extern int global;  // file2.c에 선언된 global과 연결
        ```
        - 함수 앞에 static이 붙을 경우 extern을 이용한 외부 연결 불가
    - 내부 연결
    - 무 연결

# 함수
## 1. 가변 매개 변수
매개 변수의 개수가 정해지지 않음.
```c
#include <stdio.h>
#include <stdarg.h>

void sum(int num, ...){
    int answer = 0;

    va_list argptr;     // 가변 인자 목록 포인터
    va_start(argptr, num);  // 가변 인자 목록 포인터 설정

    for(; num > 0; num--){
        answer += va_arg(argptr, int);  // int 크기만큼 인자 목록 포인터에서 값을 가져온다.
    }

    va_end(argptr);
    return answer;
}

```
## 2. 재귀 함수
>   어느날 학생이 교수님께 물었다.  
    "**재귀함수**가 무엇인가요?"  
    이에 교수님은 이렇게 답했다.  
    "잘 들어보게. 옛날에 산 꼭대기에 현자가 있었어. 질문에 모두 지혜롭게 답해주었지. 그런데 어느날, 선비가 찾아와서 물었어.  
    &emsp;"**재귀함수**가 무엇인가요?"  
    &emsp;"잘 들어보게. 옛날에 산 꼭대기에 현자가 있었어. 질문에 모두 지혜롭게 답해주었지. 그런데 어느날, 선비가 찾아와서 물었어.  
    &emsp;&emsp;"**재귀함수**가 무엇인가요?"  
    &emsp;&emsp;"잘 들어보게. 옛날에 산 꼭대기에...

# 배열
## 1. 선언
- int 형의 배열을 선언한다고 하면, 배열 명에 요소 개수를 붙여서 선언한다.

    ```c
    int a[7];   // int형 값 7개를 가지는 배열
    char b[30]; // char형 값 30개를 가지는 배열
    float c[8]; // float형 값 8개를 가지는 배열
    ```
    
    - `[]`안에는 요소의 개수가 들어가므로 음수나 0, 실수, 변수가 들어갈 수 없고 상수만 들어갈 수 있다. 
    
        ```c
        int scores[];       // 배열의 크기를 지정해야 한다.
        int scores[size];   // 배열의 크기가 변수일 수 없다.
        int scores[-2];     // 배열의 크기가 음수일 수 없다.
        int scores[6.7];    // 배열의 크기가 실수일 수 없다.
        ```
    
    - 변수의 크기로 기호상수를 사용할 수는 있다.
        
        ```c
        #define SIZE 10

        int scores[SIZE];
        ```

- 배열은 메모리의 연속적인 공간에 적용된다. 예를 들어 `a[0]`과 `a[1]`은 메모리상에 붙어있어서 차례로 접근하여 처리하기 용이하다.

## 2. 초기화 및 접근
- 다음과 같이 값을 초기화하면서 선언할 수도 있다.

    ```c
    int a[7] = {1, 2, 3, 4, 5, 6, 7};
    ```

    |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|`a[6]`
    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
    |1|2|3|4|5|6|7

- 초기화할 때 일부 요소만 값을 지정하면 나머지는 0으로 초기화된다.
    
    ```c
    int a[7] = {1, 2};
    ```

    |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|`a[6]`
    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
    |1|2|0|0|0|0|0


- 배열의 인덱스는 `0`부터 시작하므로 7개의 요소로 선언했다면 `0`부터 `6`까지의 인덱스로 접근할 수 있다.

- 배열의 각 요소에 접근할 때는 `for`문을 사용한다.
    ```c
    // 두 배열의 원소가 모두 같은지 비교

    #include <stdio.h>
    #define SIZE 5

    int main(void){
        int a[SIZE] = {1, 2, 3, 4, 5};
        int b[SIZE] = {1, 2, 3, 4, 5};

        for(int i = 0; i < SIZE; i++){
            if(a[i] != b[i]){
                printf("배열 a와 배열 b는 같지 않습니다.");
                return 0;
            }
        }

        printf("배열 a와 배열 b는 같습니다");
        return 0;
    }
    ```

- 함수에서의 배열 접근: 함수에서 매개변수로 배열을 전달하면 주소, 즉 원본이 전달된다.
    ```c
    // 배열이 아닌 다른 변수가 인자로 전달되는 경우

    #include <stdio.h>

    void swap(int a, int b){
        int temp = a;

        a = b;
        b = temp;
    }

    int main(void){
        int x = 3, y = 4;

        printf("Before Swap:\n");
        printf("x = %d\ny = %d", x, y);     // x = 3, y = 4로 출력
        swap(x, y);

        printf("After Swap:\n");
        printf("x = %d\ny = %d", x, y);    // x = 3, y = 4로 출력: swap 함수에서 전달되는 int 인자는 주소(원본)가 아니라 사본으로 값만 전달된다.
    }
    ```

    ```c
    // 배열이 함수의 인자로 전달되는 경우

    #include <stdio.h>

    void modifyArray(int a[], int size){
        for(int i = 0; i < size; i++){
            ++a[i];
        }
    }

    void printArray(int a[], int size){
        for(int i = 0; i < size; i++){
            printf("a[%d] = %d", i, a[i]);
        }
    }

    int main(void){
        int arr[5] = {1, 2, 3, 4, 5};

        modifyArray(arr, 5);
        printArray(arr, 5);
    }

    // a[0] = 2, a[1] = 3, a[2] = 4, a[3] = 5, a[4] = 6 출력
    ```
    
    - 함수에서 인자로 전달되는 배열의 변경을 방지하기 위해서는 `const`키워드를 사용한다.

        ```c
        void printArray(const int a[], size){
            ...
            a[0] = 100;     // 컴파일 오류
        }
        ```

## 3. 배열의 활용
- 정렬
    - 선택 정렬: 정렬되지 않은 요소들에서의 최솟값을 찾아 첫번째 요소와 교환

        i.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |5|7|1|3|

        &rarr; 인덱스 `0`부터 `3`까지 요소 중 최솟값 1을 첫번째 요소인 `a[0]`과 교환

        ii.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |**1**|7|5|3|

        &rarr; 정렬되지 않는 인덱스 `1`부터 `3`까지 요소 중 최솟값 3을 첫번째 요소인 `a[1]`과 교환

        iii.
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|
        |:---:|:---:|:---:|:---:|
        |**1**|**3**|5|7|
        
        &rarr; 정렬 완료

- 탐색
    - 순차 탐색: 탐색키를 배열의 각 원소와 순서대로 비교하며 원하는 값 탐색

        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|
        |:---:|:---:|:---:|:---:|:---:|:---:|
        |10|20|30|40|50|60|

        `key = 30`

        i. `a[0] != key`이므로 다음 인덱스 탐색  
        ii. `a[1] != key`이므로 다음 인덱스 탐색  
        iii. `a[2] == key`이므로 탐색 종료

    - 이진 탐색: 정렬된 배열의 중앙에 위치한 값과 탐색키를 비교하는 과정을 반복
    
        |`a[0]`|`a[1]`|`a[2]`|`a[3]`|`a[4]`|`a[5]`|
        |:---:|:---:|:---:|:---:|:---:|:---:|
        |10|20|30|40|50|60|

        `key = 50`

        i. 중앙의 `a[2]`와 `key`비교 &rarr; `a[2] < key` 이므로 뒤의 요소들과 비교  
        ii. 인덱스 `3`부터 `5`까지에서의 중앙인 `a[4]`와 `key` 비교 &rarr; `a[4] = key`이므로 탐색 종료

## 4. 2차원 배열
- 2차원 배열의 선언과 초기화:   
    기본:  `int arr[ROWS][COLUMNS]`

    i.
    ```c
    int arr[3][5] = {
        {0, 1, 2, 3, 4},
        {10, 11, 12, 13, 14},
        {20, 21, 22, 23, 24}
    };
    ```
    ii.
    ```c
    int arr[ ][5] = { 
        { 0, 1, 2, 3, 4 }, 
        { 10, 11, 12, 13, 14 }, 
        { 20, 21, 22, 23, 24 }, 
    };
    ```
    iii.
    ```c
    int arr[][5] = {1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 21, 22, 23, 24}
    ```
    &rarr; i, ii, iii 모두 아래와 같이 초기화 된다.

    | |`[0]`|`[1]`|`[2]`|`[3]`|`[4]`|
    |:---:|:---:|:---:|:---:|:---:|:---:|
    |**`[0]`**|0|1|2|3|4|
    |**`[1]`**|10|11|12|13|14|
    |**`[2]`**|20|21|22|23|24|    

- 2차원 뿐만 아니라 3차원, 4차원 등 제한 없이 n차원 배열을 선언할 수 있다. 그러나 메모리 효율을 위해 3차원 이상의 배열은 가급적 사용하지 않는 것이 좋다.

# 포인터
## 1. 변수와 메모리
- 변수는 메모리에 저장된다.
- 메모리는 바이트 단위로 접근할 수 있다.
- 자료형에 따라 차지하는 메모리 공간의 크기가 다르다. 예를 들어 `char`형은 1바이트, `int`형은 4바이트를 차지한다. 

    ```c
    #include <stdio.h>

    int main(void){
        int intData = 10;
        char charData = 'a';
    }
    ```

    |변수명|intData|charData|
    |:---:|:-----:|:-----:|
    |**변수값**|10|97|
    |**주소**|4 5 6 7|8

## 2. 변수의 주소
- 주소 연산자 `&`을 사용하여 변수의 주소에 접근할 수 있다.

    |변수명|intData|charData|
    |:---:|:-----:|:-----:|
    |**변수값**|10|97|
    |**주소**|4 5 6 7|8
    
    &rarr; `&intData = 4`, `&charData = 8`이다.

- 변수의 주소는 프로그램을 실행할 때마다 달라진다. 

## 3. 포인터 변수의 선언
- 포인터 변수는 변수의 주소를 가지고 있는 변수이다.
- `*`를 붙여 포인터 변수를 선언한다.
    
    ```c
    int *pData;
    ```

- 다음과 같이 절대 주소로 초기화할 수 있으나, 윈도우와 같은 OS환경에서는 불가능하고, 임베디드 환경에서만 가능하다.

    ```c
    char *p = (char*)0x30000000
    ```

## 4. 포인터와 변수의 연결
- 변수의 주소를 포인터 변수에 대입

    ```c
    int i = 10;
    int *pData;

    pData = &i;     // 포인터 변수 pData는 int 변수 i의 주소를 가리킴
    ```

- 간접 참조 연산자`*`를 이용하여 포인터가 가리키는 주소의 변수값을 연산

    ```c
    int i = 10;
    int *pData;

    pData = &i;

    printf("%d", *pData);   // pData 앞에 붙은 연산자`*`는 포인터가 가리키는 변수의 값을 반환환 
    ```

    Output:
    ```
    10
    ```

## 5. 포인터 사용시 주의점
- 초기화가 안된 포인터를 사용하면 안된다.

    ```c
    int main(void){
        int *pData;

        *pData = 100;   // pData가 초기화 되지 않았으므로 위험한 코드이다.

        return 0;
    }
    ```

- 포인터가 아무것도 가리키지 않을 경우에는 항상 `NULL`로 초기화 해야한다.

    ```c
    int *pData = NULL;
    ```

- 포인터와 포인터가 가리키는 변수의 타입이 일치해야 한다.

    ```c
    int main(void){
        int i;
        double *pd;

        pd = &i;    // 오류
        *pd = 36.5;

        return 0;
    }
    ```

## 6. 포인터 연산
- 증가, 감소, 덧셈, 뺄셈 연산이 가능하다.
- 증감 연산
    - 포인터 변수의 타입에 따라 증감 연산에 의해 증가/감소되는 값이 다르다.
    
        |타입|`++`연산으로 증가되는 값|
        |:---:|:---:|
        |**`char`**|1|
        |**`short`**|2|
        |**`int`**|4|
        |**`float`**|4|
        |**`double`**|8|

        - `int`형 포인터 변수의 연산

            ```c
            int a;
            int *pi;

            pi = &a;
            *pi = 4;
            ```

            &emsp;&downarrow;
            
            |변수명| | | |`a`|`a`|`a`|`a`| |
            |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
            |**변수값**| | | | | |4| | |
            |**주소**|0|1|2|3|4|5|6|7|
            |**포인터**| | | |`pi`| | | |`pi+1`|

        - `char`형 포인터 변수의 연산
            
            ```c
            char b;
            char *pc;

            pc = &b;
            *pc = 'a';
            ```

            &emsp;&downarrow;
            
            |변수명| | | |`b`| | | | |
            |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
            |**변수값**| | | |'a'| || | |
            |**주소**|0|1|2|3|4|5|6|7|
            |**포인터**| | | |`pc`|`pc+1`|`pc+2`|`pc+3`|`pc+4`|
    
- 주의점
    - `(*pi)++`는 `pi`가 가리키는 값을 증가시킨다.
    - `*pi++`는 `pi`가 가리키는 값을 가져온 후에 `pi`를 증가시킨다.  

        ```c
        #include <stdio.h>

        int main(void){
            int i = 10;
            int *pi;

            pi = &i; 

            printf("i = %d, pi = %d\n", i, pi);

            (*pi)++;
            printf("i = %d, pi = %d\n", i, pi);

            *pi++;
            printf("i = %d, pi = %d\n", i, pi);
        }
        ```

        Output:
        ```
        i=10, pi=000000FFEBCFF974
        i=11, pi=000000FFEBCFF974
        i=11, pi=000000FFEBCFF978
        ```

## 7. 포인터 형 변환
- 명시적으로 포인터 변수의 타입을 변환할 수 있다.

    ```c
    double f;
    double *pd = &f;
    int *pi;

    pi = (int*)pd;

    ```

- Lab 8. 코드 설명

    ```c
    int main(void){
        int data = 0x0A0B0C0D;
        char *pc;
        
        pc = (char*)&data;
        
        for(int i = 0; i < 4; i++) 
            printf("*(pc + %d) = %02X \n", i, *(pc + i));
        
        return 0;
    }
    ```

    - `int`형 변수 `data`는 16진수 정수 `0x0A0B0C0D`로 초기화됨.
    - `pc`는 `char`형의 포인터변수
    - `&data`는 `int`형 변수의 주소이므로 `char*`으로 형변환 하여 `pc`에 대입해야 한다. 
    - 포인터 변수`pc`를 증가시키며 해당 주소값이 가리키는 변수의 값을 출력하는데, 출력값은 시스템 유형에 따라 다르게 나온다.

        - Little-Endian: 가장 낮은 바이트(**LSB**, Least Significant Byte)가 가장 먼저 저장된다.
            
            ```
            *(pc + 0) = 0D 
            *(pc + 1) = 0C 
            *(pc + 2) = 0B 
            *(pc + 3) = 0A 
            ```

        - Big-Endian: 가장 큰 바이트(**MSB**, Most Significant Byte)가 가장 먼저 저장된다.
            
            ```
            *(pc + 0) = 0A 
            *(pc + 1) = 0B 
            *(pc + 2) = 0C 
            *(pc + 3) = 0D 
            ```
        
        - 대부분의 Windows, Linux(x64, x86)환경에서는 **Little-Endian**을 사용한다.

## 8. 인수 전달
- 값에 의한 호출(Call By Value): 변수의 복사본을 통해 **값**을 전달한다.
- 참조에 의한 호출(Call By Reference): 변수의 **원본**이 전달되는 방법으로, C에서는 포인터를 이용한다.

- Swap 함수
    - Call By Value

        ```c
        #include <stdio.h>

        void swap(int x, int y){
            int temp = x;

            x = y;
            y = temp;
        }

        int main(void){
            int a = 100, b = 200;

            swap(a, b);     // swap함수의 인자로 전달 된 것은 복사본으로, 실제로 a, b의 값이 바뀌지는 않았음.

            printf("a = %d\nb = %d", a, b);     // a = 100, b = 200으로 출력됨.   
            return 0;
        }

    - Call By Reference

        ```c
        #include <Stdio.h>

        void swap(int *x, int *y){
            int temp = *x;

            *x = *y;
            *y = temp;
        }

        int main(void){
            int a = 100, b = 200;

            swap(&a, &b);       // swap함수의 인자로 a, b의 주소가 전달 되었으므로, 실제로 값을 변경할 수 있음.

            printf("a = %d\nb = %d", a, b);     // a = 200, b = 100으로 출력됨.
            return 0;
        }
        ```

- `scanf()`에서의 인수 전달
    
    ```c
    #include <stdio.h>

    int main(void){
        int input;

        printf("정수를 입력하세요:");
        scanf("%d", &input);

        printf("input = %d", input);

        return 0;
    }
    ```

    &rarr; `input`변수에 직접 접근하여 값을 변형해야 하므로 인자로 `&input`과 같이 주소를 받는 것이다.

- 함수가 두개 이상의 값을 반환해야 하는 경우 포인터 변수를 인자로 전달 받아 결과를 변수에 저장해도 된다. *(Lab.11 코드 참고)*

## 9. 포인터와 배열
- 포인터는 배열처럼 사용할 수 있고, 인덱스 표기법도 사용할 수 있다.

    ```c
    #include <stdio.h>

    int main(void){
        int arr[] = {10, 20, 30, 40};
        int *p;

        p = arr;

        printf("arr[0] = %d, arr[1] = %d, arr[2] = %d\n", arr[0], arr[1], arr[2]);
        printf("p[0] = %d, p[1] = %d, p[2] = %d", p[0], p[1], p[2]);

        return 0;
    }
    ```

    Output:
    
    ```
    arr[0] = 10, arr[1] = 20, arr[2] = 30
    p[0] = 10, p[1] = 20, p[2] = 30
    ```
    
    &rarr; 포인터를 배열처럼 사용할 수 있다.

    |변수명|`arr[0]`|`arr[1]`|`arr[2]`|`arr[3]`|
    |:---:|:---:|:---:|:---:|:---:|
    |**주소**|4 5 6 7|8 9 10 11|12 13 14 15|16 17 18 19 20|
    |**포인터**|`p`|`p+1`   |`p+2`   |`p+3`   |

- 함수의 매개변수로 배열을 사용하는 경우 배열 전체의 복사본을 만드는 것은 비효율적이므로 주소를 전달하고, 기억 장소가 할당되지 않는다. 따라서 배열 매개 변수는 포인터로 생각할 수 있다.

## 10. 포인터 사용의 장점
- 연결 리스트, 이진 트리 등의 자료구조를 만들 수 있다.
- 참조에 의한 호출(Call By Reference)를 구현할 수 있다.
- 메모리 매핑 하드웨어
- 동적 메모리 할당

# 스트림(Stream)
## 1. 스트림의 개념
- 입력과 출력을 바이트들의 흐름으로 생각하는 것.
- 버퍼: 데이터를 일시적으로 저장하는 메모리 영역으로, 데이터를 모아놨다가 일정량이 채워지면 한번에 처리한다.

## 2. 표준 입출력 스트림
- `stdin` : 입력값을 위한 데이터 스트림(키보드)
- `stdout` : 출력을 위한 데이터 스트림(모니터)
- `stderr` : 오류메시지, 진단을 위한 데이터 스트림(모니터)

## 3. 입출력 함수
- 형식이 없는 입출력
    |표준 스트림|일반 스트림|구분|기타|
    |:---:|:---:|:---:|:---:|
    |`getchar()`|`fgetc(FILE * f, ...)`|문자열 입력|
    |`putchar()`|`fputc(FILE * f, ...)`|문자열 출력|
    |`gets()`|`fgets(FILE * f, ...)`|문자열 입력| `gets()`는 입력 버퍼의 크기를 확인하지 않아 버퍼오버플로우가 발생할 위험이 있고, `fgets(FILE * f)`와 달리 개행문자까지 입력받을 수 있다.|
    |`puts()`|`fputs(FILE * f, ...)`|문자열 출력|

    - 표준 스트림으로 구분된 함수들은 표준 입출력 스트림만 사용하고, 일반 스트림으로 구분된 함수는 스트림을 지정할 수 있다.

- 형식이 있는 입출력
    - `printf()`
    - `scanf()`

- `scanf()`와 `fgets()` 및 `gets()`의 차이점:
    - `scanf()`는 `\n`과  공백을 모두 `\0`으로 처리하므로 공백 포함 문자열을 입력받을 수 없다.
    - `gets()`는 공백 포함 문자열을 받을 수 있고 `\n`은 문자열의 끝을 의미하는 `\0`으로 처리한다.
    - `fgets()`는 `\n`다음 인덱스의 값을 `\0`으로 처리하므로 공백 포함 문자열을 입력받을 수 있고, `\n` 뒤에 `\0`을 덧붙인다.

        ```c
        #include <stdio.h>

        int main(void){
            char strInput1[100], strInput2[100], strInput3[100];
            
            scanf("%s", strInput1);
            strInput2 = gets();
            strInput3 = fgets(strInput3, sizeof(strInput3), stdin);
        }
        ```
        - `ab cd` 입력 &rarr;

            |`strInput1[0]`|`strInput1[1]`|`strInput1[2]`|`strInput1[3]`|`strInput1[4]`|
            |:---:|:---:|:---:|:---:|:---:|
            |`'a'`|`'b'`|`'c'`|`'d'`|`'\0'`|

            |`strInput2[0]`|`strInput2[1]`|`strInput2[2]`|`strInput2[3]`|`strInput2[4]`|`strInput2[5]`|
            |:---:|:---:|:---:|:---:|:---:|:---:|
            |`'a'`|`'b'`|`' '`|`'c'`|`'d'`|`'\0'`|

            |`strInput3[0]`|`strInput3[1]`|`strInput3[2]`|`strInput3[3]`|`strInput3[4]`|`strInput3[5]`|`strInput3[6]`|
            |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
            |`'a'`|`'b'`|`' '`|`'c'`|`'d'`|`'\n'`|`'\0'`|

# 파일
## 1. 파일의 개념
- 파일이 필요한 이유: 데이터를 모두 메모리에 저장하면 전원이 꺼지면 모두 사라지므로 하드디스크에 파일 형태로 데이터를 저장하여 사용할 수 있다.
- 파일의 개념: 파일은 일련의 연속된 바이트로, 파일의 모든 데이터들은 바이트로 저장된다.
- 파일의 데이터: 파일에 4개의 바이트가 들어있으면, 하나의 `int`정수로 해석할 수있지만, 하나의 `float`실수 또는 4개의 `char`문자로 해석할 수도 있다.

## 2. 텍스트 파일
- 텍스트 파일은 .txt나 소스코드파일 처럼 읽을 수 있는 텍스트로 저장되는 파일이다.
- 텍스트 파일은 아스키코드로 저장되고, 연속적인 라인들로 구성된다.
- 운영체제마다 줄바꿈 표시가 다르다.

## 3. 파일 처리
- `FILE`구조체를 이용하여 디스크의 파일에 접근할 수 있다.(`FILE`구조체는 `<stdio.h>`에 정의되어있다.)
- 파일 포인터를 통해 `FILE`구조체의 주소에 접근할 수 있다.
- 파일 모드
    - `"r"` : 읽기 모드
    - `"w"` : 쓰기 모드(기존의 파일이 있으면 기존의 내용이 지워진다.)
    - `"a"` : 추가 모드(기존의 파일이 있으면 파일의 끝에 데이터가 추가되고, 기존의 내용은 절대 지워지지 않는다.)
    - `"r+"` : 읽기 모드로 열지만, 쓰기 모드로 전환가능
    - `"w+"` : 쓰기 모드로 파일을 생성하지만, 읽기 모드로 전환가능
    - `"a+"` : 추가 모드로 파일을 열지만, 읽기 모드로 전환가능
    - `"t"` : 텍스트 파일 모드
    - `"b"` : 이진 파일 모드

    * `"r+"`, `"w+"`, `"a+"`는 읽고 쓰기가 모두 가능한 Update Mode이다. 읽기 모드와 쓰기 모드 및 추가 모드간 전환을 위해서는 `fflush()`, `fsetpos()`, `fseek()`, `rewind()`함수 중 하나를 호출해야 한다.

- 파일 처리 과정  

    i. 파일 열기  

    ```c
    FILE *pWrite, *pRead;

    pWrite = fopen("write.txt", "w");
    pRead = fopen("read.txt", "r");   // fopen함수는 FILE 포인터를 반환
    ```

    ii. 문자열 입출력

    ```c
    char str[100];
    
    fprintf(pWrite, "lorem ipsum");     // wtire.txt에 텍스트 작성성

    while(!feof(pRead)){        // 파일 포인터가 파일 끝에 도달할 때까지 반복. 
        fscanf(pRead, "%s", str);       // scanf와 유사하게 사용
    }
    ```

    iii. 파일 닫기

    ```c
    fclose(pWrite);     // 새로 쓴 내용이 저장된다.
    fclose(pRead);
    ```

    iv. 기타 함수

    ```c
    int foef(FILE *stream);     // 파일의 끝에 도달하면 true 반환
    int rename(const char *oldname, const char *newname);       // 파일의 이름 변경
    FILE *tmpfile();        // 임시 파일을 생성하여 반환
    int ferror(FILE *stream);   // 스트림의 오류 상태를 반환(오류 발생시 true 반환)
    ```

- `EOF`: 파일의 끝을 나타내는 특수기호

    


